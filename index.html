<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Voyagers - Login & Voice Call</title>
    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@7.0.0/dist/browser/signalr.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            text-align: center;
        }
        .header h1 { font-size: 2rem; margin-bottom: 8px; }
        .content { padding: 24px; }
        .section {
            margin-bottom: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 20px;
            background: #f9fafb;
        }
        .section h2 {
            color: #4f46e5;
            margin-bottom: 16px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 8px;
        }
        .form-group { margin-bottom: 14px; }
        label { display: block; margin-bottom: 6px; font-weight: 600; color: #374151; }
        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-size: 14px;
        }
        input:focus, select:focus { outline: none; border-color: #6366f1; }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            margin-right: 8px;
            margin-top: 8px;
        }
        button:hover { opacity: 0.95; }
        .response {
            margin-top: 16px;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #4f46e5;
            background: #eef2ff;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .hidden { display: none; }
        .token-display {
            background: #fff7ed;
            border: 1px solid #fdba74;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 16px;
            word-break: break-all;
            font-size: 12px;
        }
        .subnote { font-size: 12px; color: #6b7280; margin-top: 6px; }
        .status {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        .pill {
            padding: 6px 10px;
            border-radius: 999px;
            background: #eef2ff;
            color: #312e81;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Motion Voyagers</h1>
            <p>Login and WebRTC Voice Calling</p>
            <div style="margin-top: 10px;">
                <label style="color: #e0e7ff; font-weight: 600;">API Base URL:</label>
                <select id="baseUrlSelect" onchange="changeBaseUrl()" style="padding: 6px; border-radius: 6px; border: none;">
                    <option value="https://motionvoyagers.csdevhub.com/">Production</option>
                    <option value="http://localhost:5299/">Localhost</option>
                </select>
                <div class="pill" id="baseUrlDisplay"></div>
            </div>
        </div>

        <div class="content">
            <div class="token-display" id="tokenDisplay">
                <strong>Auth Token:</strong> <span id="tokenValue">Not logged in</span>
                <button onclick="clearToken()" style="float: right; padding: 4px 10px; margin: 0;">Clear</button>
            </div>

            <div class="section">
                <h2>üîê Login</h2>
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="loginEmail" placeholder="user@example.com">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="loginPassword" placeholder="Password">
                </div>
                <button onclick="login()">Login</button>
                <div id="authResponse" class="response hidden"></div>
            </div>

            <div class="section">
                <h2>üìû WebRTC Voice Calling</h2>
                <div class="form-group">
                    <label>Session ID</label>
                    <input type="text" id="webrtcSessionId" placeholder="GUID">
                </div>
                <div>
                    <button onclick="connectVoiceHub()">Connect</button>
                    <button onclick="disconnectVoiceHub()">Disconnect</button>
                    <button onclick="startAudioCapture()">Start Microphone</button>
                    <button onclick="stopAudioCapture()">Stop Microphone</button>
                </div>
                <div class="status">
                    <span class="pill">Status: <span id="hubStatus">Disconnected</span></span>
                    <span class="pill">Connection ID: <span id="connectionId">-</span></span>
                    <span class="pill">Participants: <span id="participantsList">None</span></span>
                </div>
                <div id="webrtcResponse" class="response hidden"></div>
            </div>

            <div class="section">
                <h2>üéµ Music (mix with microphone)</h2>
                <div class="form-group">
                    <label>Track (hotlink-friendly samples)</label>
                    <select id="musicTrack">
                        <option value="https://cdn.jsdelivr.net/npm/test-audio@2.1.0/audio/8000__cfork__cf-fx-bloibb.mp3">üéµ FX Bloibb (mp3)</option>
                        <option value="https://cdn.jsdelivr.net/npm/test-audio@2.1.0/audio/75344__neotone__drip2.wav">üéµ Drip2 (wav)</option>
                        <option value="https://cdn.jsdelivr.net/npm/test-audio@2.1.0/audio/50775__smcameron__drips2.ogg">üéµ Drips2 (ogg)</option>
                        <option value="https://file-examples.com/storage/fe51d49f91f03a7b6ee546f/2017/11/file_example_MP3_5MG.mp3">üéµ Long Track 1 (~5MB mp3)</option>
                        <option value="https://file-examples.com/storage/fe51d49f91f03a7b6ee546f/2017/11/file_example_MP3_2MG.mp3">üéµ Long Track 2 (~2MB mp3)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Or upload an mp3</label>
                    <input type="file" id="musicUpload" accept="audio/mpeg,audio/mp3,audio/*" />
                    <button onclick="useUploadedMusic()">Use Upload</button>
                </div>
                <div>
                    <button onclick="startMusic()">Play with Mic</button>
                    <button onclick="stopMusic()">Stop Music</button>
                </div>
                <p class="subnote">Music is mixed into your microphone stream and sent to the call.</p>
                <div id="musicResponse" class="response hidden"></div>
                <audio id="musicAudio" crossorigin="anonymous"></audio>
            </div>
        </div>
    </div>

    <script>
        const STORAGE_KEYS = { token: 'mv_api_token', baseUrl: 'mv_api_base_url' };
        const BASE_URLS = { prod: 'https://motionvoyagers.csdevhub.com/', local: 'http://localhost:5299/' };
        let BASE_URL = localStorage.getItem(STORAGE_KEYS.baseUrl) || BASE_URLS.prod;
        let authToken = localStorage.getItem(STORAGE_KEYS.token) || '';

        function changeBaseUrl() {
            const select = document.getElementById('baseUrlSelect');
            BASE_URL = select.value;
            localStorage.setItem(STORAGE_KEYS.baseUrl, BASE_URL);
            document.getElementById('baseUrlDisplay').textContent = BASE_URL;
        }

        function showResponse(elementId, data, type = 'success') {
            const el = document.getElementById(elementId);
            el.className = `response ${type}`;
            el.textContent = JSON.stringify(data, null, 2);
            el.classList.remove('hidden');
        }

        function hideResponse(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function getAuthHeaders() {
            const headers = { 'Content-Type': 'application/json' };
            if (authToken) headers['Authorization'] = `Bearer ${authToken}`;
            return headers;
        }

        function saveToken(token) {
            authToken = token;
            localStorage.setItem(STORAGE_KEYS.token, token);
            updateTokenDisplay();
        }

        function clearToken() {
            authToken = '';
            localStorage.removeItem(STORAGE_KEYS.token);
            updateTokenDisplay();
        }

        function updateTokenDisplay() {
            document.getElementById('tokenValue').textContent = authToken || 'Not logged in';
        }

        async function apiCall(endpoint, method = 'GET', body = null, authRequired = true) {
            const url = BASE_URL.replace(/\/$/, '') + '/' + endpoint.replace(/^\//, '');
            const options = { method, headers: getAuthHeaders() };
            if (body) options.body = JSON.stringify(body);
            if (!authRequired) delete options.headers['Authorization'];

            try {
                const response = await fetch(url, options);
                const data = await response.json().catch(() => ({}));
                return { ok: response.ok, status: response.status, data };
            } catch (err) {
                return { ok: false, status: 0, data: { error: err.message } };
            }
        }

        async function login() {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            if (!email || !password) {
                showResponse('authResponse', { error: 'Email and password are required' }, 'error');
                return;
            }
            const result = await apiCall('api/Auth/login', 'POST', { email, password }, false);
            showResponse('authResponse', result.data, result.ok ? 'success' : 'error');
            if (result.ok && result.data?.token) saveToken(result.data.token);
        }

        // ========== WebRTC & SignalR ==========
        let voiceHubConnection = null;
        let localStream = null;
        let peerConnections = new Map();
        let localConnectionId = null;
        let currentSessionId = null;
        let musicAudio = null;
        let musicCtx = null;
        let musicDest = null;
        let mixedStream = null;
        let isMusicActive = false;
        let uploadedMusicUrl = null;

        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' }
        ];

        async function connectVoiceHub() {
            hideResponse('webrtcResponse');
            if (!authToken) {
                showResponse('webrtcResponse', { error: 'Please login first' }, 'error');
                return;
            }
            const sessionId = document.getElementById('webrtcSessionId').value.trim();
            if (!sessionId) {
                showResponse('webrtcResponse', { error: 'Please enter a Session ID' }, 'error');
                return;
            }

            try {
                const hubUrl = BASE_URL.replace(/\/$/, '') + '/hubs/voice';
                voiceHubConnection = new signalR.HubConnectionBuilder()
                    .withUrl(hubUrl, {
                        accessTokenFactory: () => authToken,
                        transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling,
                        skipNegotiation: false,
                        withCredentials: false
                    })
                    .withAutomaticReconnect()
                    .configureLogging(signalR.LogLevel.Information)
                    .build();

                voiceHubConnection.on('ReceiveOffer', async (callerId, offerSdp) => { await handleOffer(callerId, offerSdp); });
                voiceHubConnection.on('ReceiveAnswer', async (callerId, answerSdp) => { await handleAnswer(callerId, answerSdp); });
                voiceHubConnection.on('ReceiveIceCandidate', (callerId, candidateJson) => { handleIceCandidate(callerId, candidateJson); });
                voiceHubConnection.on('ParticipantJoined', (connectionId) => { updateParticipantsList(); callUser(connectionId); });
                voiceHubConnection.on('ParticipantLeft', (connectionId) => { closePeerConnection(connectionId); updateParticipantsList(); });
                voiceHubConnection.on('SessionParticipants', (participants) => {
                    participants.forEach(pid => { if (pid !== localConnectionId) callUser(pid); });
                    updateParticipantsList();
                });

                voiceHubConnection.onclose((error) => {
                    document.getElementById('hubStatus').textContent = 'Disconnected';
                    if (error) showResponse('webrtcResponse', { error: error.message || error }, 'error');
                });

                await voiceHubConnection.start();
                localConnectionId = voiceHubConnection.connectionId;
                currentSessionId = sessionId;
                document.getElementById('hubStatus').textContent = 'Connected';
                document.getElementById('connectionId').textContent = localConnectionId;

                await voiceHubConnection.invoke('JoinSessionGroup', sessionId);

                showResponse('webrtcResponse', { message: 'Connected to voice hub', sessionId, connectionId: localConnectionId }, 'success');
            } catch (error) {
                showResponse('webrtcResponse', { error: error.message || error }, 'error');
                document.getElementById('hubStatus').textContent = 'Connection Failed';
            }
        }

        async function disconnectVoiceHub() {
            hideResponse('webrtcResponse');
            if (voiceHubConnection) {
                if (currentSessionId) {
                    try { await voiceHubConnection.invoke('LeaveSessionGroup', currentSessionId); } catch {}
                }
                try { await voiceHubConnection.stop(); } catch {}
                voiceHubConnection = null;
            }
            peerConnections.forEach((pc, id) => closePeerConnection(id));
            peerConnections.clear();
            if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
            document.getElementById('hubStatus').textContent = 'Disconnected';
            document.getElementById('connectionId').textContent = '-';
            document.getElementById('participantsList').textContent = 'None';
            showResponse('webrtcResponse', { message: 'Disconnected' }, 'success');
        }

        async function startAudioCapture() {
            hideResponse('webrtcResponse');
            // If music is active, stop it first
            if (isMusicActive) {
                stopMusic();
            }
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                showResponse('webrtcResponse', { message: 'Microphone ready' }, 'success');
            } catch (error) {
                showResponse('webrtcResponse', { error: `Microphone error: ${error.message}` }, 'error');
            }
        }

        function stopAudioCapture() {
            hideResponse('webrtcResponse');
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                showResponse('webrtcResponse', { message: 'Microphone stopped' }, 'success');
            }
        }

        function getOutgoingStream() {
            if (isMusicActive && mixedStream) return mixedStream;
            return localStream;
        }

        async function callUser(targetConnectionId) {
            let streamToUse = getOutgoingStream();
            if (!streamToUse) {
                await startAudioCapture();
                streamToUse = getOutgoingStream();
                if (!streamToUse) return;
            }
            let pc = peerConnections.get(targetConnectionId);
            if (!pc || pc.connectionState === 'closed') {
                pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
                peerConnections.set(targetConnectionId, pc);

                streamToUse.getTracks().forEach(track => pc.addTrack(track, streamToUse));

                pc.ontrack = (event) => {
                    const audio = new Audio();
                    audio.srcObject = event.streams[0];
                    audio.play().catch(() => {});
                };

                pc.onicecandidate = (event) => {
                    if (event.candidate && voiceHubConnection) {
                        const candidateJson = JSON.stringify({
                            candidate: event.candidate.candidate,
                            sdpMLineIndex: event.candidate.sdpMLineIndex,
                            sdpMid: event.candidate.sdpMid
                        });
                        voiceHubConnection.invoke('SendIceCandidate', targetConnectionId, candidateJson).catch(() => {});
                    }
                };

                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    await voiceHubConnection.invoke('SendOffer', targetConnectionId, offer.sdp);
                } catch {}
            }
        }

        async function handleOffer(callerId, offerSdp) {
            let streamToUse = getOutgoingStream();
            if (!streamToUse) {
                await startAudioCapture();
                streamToUse = getOutgoingStream();
                if (!streamToUse) return;
            }

            let pc = peerConnections.get(callerId);
            if (!pc || pc.connectionState === 'closed') {
                pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
                peerConnections.set(callerId, pc);
                streamToUse.getTracks().forEach(track => pc.addTrack(track, streamToUse));
                pc.ontrack = (event) => {
                    const audio = new Audio();
                    audio.srcObject = event.streams[0];
                    audio.play().catch(() => {});
                };
                pc.onicecandidate = (event) => {
                    if (event.candidate && voiceHubConnection) {
                        const candidateJson = JSON.stringify({
                            candidate: event.candidate.candidate,
                            sdpMLineIndex: event.candidate.sdpMLineIndex,
                            sdpMid: event.candidate.sdpMid
                        });
                        voiceHubConnection.invoke('SendIceCandidate', callerId, candidateJson).catch(() => {});
                    }
                };
            }

            try {
                await pc.setRemoteDescription({ type: 'offer', sdp: offerSdp });
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await voiceHubConnection.invoke('SendAnswer', callerId, answer.sdp);
            } catch {}
        }

        async function handleAnswer(callerId, answerSdp) {
            const pc = peerConnections.get(callerId);
            if (!pc) return;
            try { await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp }); } catch {}
        }

        function handleIceCandidate(callerId, candidateJson) {
            const pc = peerConnections.get(callerId);
            if (!pc) return;
            try { pc.addIceCandidate(JSON.parse(candidateJson)).catch(() => {}); } catch {}
        }

        function closePeerConnection(connectionId) {
            const pc = peerConnections.get(connectionId);
            if (pc) {
                pc.getSenders().forEach(sender => sender.track?.stop());
                pc.close();
                peerConnections.delete(connectionId);
            }
        }

        function updateParticipantsList() {
            const participants = Array.from(peerConnections.keys());
            document.getElementById('participantsList').textContent = participants.length ? participants.join(', ') : 'None';
        }

        function applyStreamToPeers(stream) {
            peerConnections.forEach(pc => {
                const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
                if (sender && stream.getAudioTracks().length > 0) {
                    sender.replaceTrack(stream.getAudioTracks()[0]).catch(() => {});
                }
            });
        }

        async function startMusic() {
            hideResponse('musicResponse');
            // Stop mic while music plays
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
            }

            if (!musicAudio) musicAudio = document.getElementById('musicAudio');
            const url = uploadedMusicUrl || document.getElementById('musicTrack').value;
            musicAudio.src = url;

            if (!musicCtx) musicCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (!musicDest) musicDest = musicCtx.createMediaStreamDestination();

            // Build mixer: music only
            let musicSource;
            try {
                musicSource = musicCtx.createMediaElementSource(musicAudio);
            } catch (e) {
                // if already created, reuse
                musicSource = musicAudio._sourceNode;
            }
            if (!musicAudio._sourceNode) musicAudio._sourceNode = musicSource;

            musicSource.connect(musicDest);
            musicSource.connect(musicCtx.destination);

            mixedStream = musicDest.stream;
            isMusicActive = true;

            await musicAudio.play().catch(err => {
                showResponse('musicResponse', { error: `Play blocked: ${err.message}` }, 'error');
            });

            applyStreamToPeers(mixedStream);
            showResponse('musicResponse', { message: 'Music mixed with mic and sent to call' }, 'success');
        }

        function stopMusic() {
            hideResponse('musicResponse');
            if (musicAudio) {
                musicAudio.pause();
                musicAudio.currentTime = 0;
            }
            isMusicActive = false;
            mixedStream = null;
            if (localStream) applyStreamToPeers(localStream);
            showResponse('musicResponse', { message: 'Music stopped, mic only' }, 'success');
        }

        function useUploadedMusic() {
            hideResponse('musicResponse');
            const fileInput = document.getElementById('musicUpload');
            if (!fileInput.files || fileInput.files.length === 0) {
                showResponse('musicResponse', { error: 'Choose an mp3 file first' }, 'error');
                return;
            }
            const file = fileInput.files[0];
            // Revoke previous object URL
            if (uploadedMusicUrl && uploadedMusicUrl.startsWith('blob:')) {
                URL.revokeObjectURL(uploadedMusicUrl);
            }
            uploadedMusicUrl = URL.createObjectURL(file);
            showResponse('musicResponse', { message: `Loaded upload: ${file.name}` }, 'success');
        }

        function init() {
            document.getElementById('baseUrlSelect').value = BASE_URL;
            document.getElementById('baseUrlDisplay').textContent = BASE_URL;
            updateTokenDisplay();
        }

        window.onload = init;
    </script>
</body>
</html>

