<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Group Voice Call</title>
    <link rel="icon" href="data:,">
</head>

<body>
    <h2>Group Voice Call (Firebase + WebRTC)</h2>

    <input id="roomId" placeholder="Room ID">
    <button id="join">Join</button>
    <button id="leave" style="display:none;">Leave Call</button>
    <div id="status"></div>

    <script type="module">
        import { initializeApp } from
            "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";

        import {
            getFirestore,
            doc,
            setDoc,
            getDocs,
            onSnapshot,
            collection,
            addDoc
        } from
            "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBRbfuMB_J7ADzWYcnI2UmUmTuLYoY3G6Q",
            authDomain: "webrtc-a3cd5.firebaseapp.com",
            projectId: "webrtc-a3cd5",
            storageBucket: "webrtc-a3cd5.firebasestorage.app",
            messagingSenderId: "203007627814",
            appId: "1:203007627814:web:a947bb1227f5e390f78ce7"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        console.log("Firebase loaded successfully");

        const userId = crypto.randomUUID();
        let localStream;
        let peers = {};
        let currentRoomId = null;
        let unsubscribers = [];

        const servers = {
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        };

        async function joinRoom() {
            const roomId = document.getElementById("roomId").value;
            if (!roomId) return alert("Enter Room ID");

            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            currentRoomId = roomId;
            
            document.getElementById("join").style.display = "none";
            document.getElementById("leave").style.display = "inline";
            document.getElementById("roomId").disabled = true;
            document.getElementById("status").textContent = "Connected to room: " + roomId;

            const participantsRef = collection(db, "rooms", roomId, "participants");
            await setDoc(doc(participantsRef, userId), { joined: Date.now() });

            const snapshot = await getDocs(participantsRef);
            snapshot.forEach(p => {
                const data = p.data();
                if (p.id !== userId && !data.left) {
                    connect(roomId, p.id, true);
                }
            });

            const unsubscribe = onSnapshot(participantsRef, snap => {
                snap.docChanges().forEach(c => {
                    if (c.type === "added" && c.doc.id !== userId && !c.doc.data().left) {
                        connect(roomId, c.doc.id, false);
                    }
                    if (c.type === "modified" && c.doc.data().left && peers[c.doc.id]) {
                        // Peer left, clean up their connection
                        peers[c.doc.id].close();
                        delete peers[c.doc.id];
                        // Remove their audio element
                        document.querySelectorAll("audio").forEach(audio => {
                            if (audio.id === c.doc.id) audio.remove();
                        });
                    }
                });
            });
            unsubscribers.push(unsubscribe);
        }

        async function connect(roomId, peerId, caller) {
            const pc = new RTCPeerConnection(servers);
            peers[peerId] = pc;

            localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

            pc.ontrack = e => {
                const audio = document.createElement("audio");
                audio.srcObject = e.streams[0];
                audio.autoplay = true;
                audio.id = peerId;
                document.body.appendChild(audio);
            };

            // My outgoing candidates
            const myCandRef = collection(
                db, "rooms", roomId, "participants",
                userId, "connections", peerId, "candidates"
            );

            pc.onicecandidate = e =>
                e.candidate && addDoc(myCandRef, e.candidate.toJSON());

            // My connection document (where I write my offer/answer)
            const myConnRef = doc(
                db, "rooms", roomId, "participants",
                userId, "connections", peerId
            );

            // Peer's connection document (where I read their offer/answer)
            const peerConnRef = doc(
                db, "rooms", roomId, "participants",
                peerId, "connections", userId
            );

            // Peer's candidates
            const peerCandRef = collection(peerConnRef, "candidates");

            // Queue for candidates that arrive before remote description
            const candidateQueue = [];

            onSnapshot(peerConnRef, async snap => {
                const data = snap.data();
                if (data?.offer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(data.offer);
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    await setDoc(myConnRef, { answer }, { merge: true });
                    // Add queued candidates
                    candidateQueue.forEach(c => pc.addIceCandidate(c));
                    candidateQueue.length = 0;
                }
                if (data?.answer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(data.answer);
                    // Add queued candidates
                    candidateQueue.forEach(c => pc.addIceCandidate(c));
                    candidateQueue.length = 0;
                }
            });

            onSnapshot(peerCandRef, snap => {
                snap.docChanges().forEach(c => {
                    try {
                        const candidate = new RTCIceCandidate(c.doc.data());
                        if (pc.currentRemoteDescription) {
                            pc.addIceCandidate(candidate);
                        } else {
                            candidateQueue.push(candidate);
                        }
                    } catch (e) {
                        console.error("Error adding ICE candidate:", e);
                    }
                });
            });

            if (caller) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await setDoc(myConnRef, { offer });
            }
        }

        async function leaveRoom() {
            if (!currentRoomId) return;

            // Unsubscribe from all Firebase listeners
            unsubscribers.forEach(unsub => unsub());
            unsubscribers = [];

            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            // Close all peer connections
            Object.values(peers).forEach(pc => pc.close());
            peers = {};

            // Remove from Firebase
            const participantsRef = collection(db, "rooms", currentRoomId, "participants");
            await setDoc(doc(participantsRef, userId), { left: Date.now() }, { merge: true });

            // Remove all audio elements
            document.querySelectorAll("audio").forEach(audio => audio.remove());

            // Reset UI
            document.getElementById("join").style.display = "inline";
            document.getElementById("leave").style.display = "none";
            document.getElementById("roomId").disabled = false;
            document.getElementById("status").textContent = "Left the call";
            
            currentRoomId = null;
        }

        document.getElementById("join").onclick = joinRoom;
        document.getElementById("leave").onclick = leaveRoom;
    </script>
</body>
</html>
