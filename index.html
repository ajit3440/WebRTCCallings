<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Group Voice Call</title>
    <link rel="icon" href="data:,">
</head>

<body>
    <h2>Group Voice Call (Firebase + WebRTC)</h2>

    <input id="roomId" placeholder="Room ID">
    <button id="join">Join</button>
    <button id="leave" style="display:none;">Leave Call</button>
    <button id="shareScreen" style="display:none;">Share Screen</button>
    <div id="status"></div>
    <div id="videos" style="display:flex; flex-wrap:wrap; gap:10px; margin-top:20px;"></div>

    <script type="module">
        import { initializeApp } from
            "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";

        import {
            getFirestore,
            doc,
            setDoc,
            getDocs,
            onSnapshot,
            collection,
            addDoc
        } from
            "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBRbfuMB_J7ADzWYcnI2UmUmTuLYoY3G6Q",
            authDomain: "webrtc-a3cd5.firebaseapp.com",
            projectId: "webrtc-a3cd5",
            storageBucket: "webrtc-a3cd5.firebasestorage.app",
            messagingSenderId: "203007627814",
            appId: "1:203007627814:web:a947bb1227f5e390f78ce7"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        console.log("Firebase loaded successfully");

        const userId = crypto.randomUUID();
        let localStream;
        let screenStream;
        let peers = {};
        let currentRoomId = null;
        let unsubscribers = [];

        const servers = {
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        };

        async function joinRoom() {
            const roomId = document.getElementById("roomId").value;
            if (!roomId) return alert("Enter Room ID");

            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            currentRoomId = roomId;
            
            document.getElementById("join").style.display = "none";
            document.getElementById("leave").style.display = "inline";
            document.getElementById("shareScreen").style.display = "inline";
            document.getElementById("roomId").disabled = true;
            document.getElementById("status").textContent = "Connected to room: " + roomId;

            const participantsRef = collection(db, "rooms", roomId, "participants");
            await setDoc(doc(participantsRef, userId), { joined: Date.now() });

            const snapshot = await getDocs(participantsRef);
            snapshot.forEach(p => {
                const data = p.data();
                if (p.id !== userId && !data.left) {
                    connect(roomId, p.id, true);
                }
            });

            const unsubscribe = onSnapshot(participantsRef, snap => {
                snap.docChanges().forEach(c => {
                    if (c.type === "added" && c.doc.id !== userId && !c.doc.data().left) {
                        connect(roomId, c.doc.id, false);
                    }
                    if (c.type === "modified" && c.doc.data().left && peers[c.doc.id]) {
                        // Peer left, clean up their connection
                        if (peers[c.doc.id].unsubscribers) {
                            peers[c.doc.id].unsubscribers.forEach(unsub => unsub());
                        }
                        peers[c.doc.id].close();
                        delete peers[c.doc.id];
                        // Remove their audio and video elements
                        const audio = document.getElementById("audio-" + c.doc.id);
                        const video = document.getElementById("video-" + c.doc.id);
                        if (audio) audio.remove();
                        if (video) video.remove();
                    }
                });
            });
            unsubscribers.push(unsubscribe);
        }

        async function connect(roomId, peerId, caller) {
            const pc = new RTCPeerConnection(servers);
            peers[peerId] = pc;
            peers[peerId].unsubscribers = [];

            localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
            if (screenStream) {
                screenStream.getTracks().forEach(t => pc.addTrack(t, screenStream));
            }

            pc.ontrack = e => {
                const stream = e.streams[0];
                const trackKind = e.track.kind;
                
                if (trackKind === "video") {
                    // Display screen share
                    let video = document.getElementById("video-" + peerId);
                    if (!video) {
                        video = document.createElement("video");
                        video.id = "video-" + peerId;
                        video.autoplay = true;
                        video.style.width = "400px";
                        video.style.border = "2px solid #333";
                        document.getElementById("videos").appendChild(video);
                    }
                    video.srcObject = stream;
                } else if (trackKind === "audio") {
                    // Audio track
                    let audio = document.getElementById("audio-" + peerId);
                    if (!audio) {
                        audio = document.createElement("audio");
                        audio.id = "audio-" + peerId;
                        audio.autoplay = true;
                        document.body.appendChild(audio);
                    }
                    if (!audio.srcObject) {
                        audio.srcObject = stream;
                    }
                }
            };

            // My outgoing candidates
            const myCandRef = collection(
                db, "rooms", roomId, "participants",
                userId, "connections", peerId, "candidates"
            );

            pc.onicecandidate = e =>
                e.candidate && addDoc(myCandRef, e.candidate.toJSON());

            // My connection document (where I write my offer/answer)
            const myConnRef = doc(
                db, "rooms", roomId, "participants",
                userId, "connections", peerId
            );

            // Peer's connection document (where I read their offer/answer)
            const peerConnRef = doc(
                db, "rooms", roomId, "participants",
                peerId, "connections", userId
            );

            // Peer's candidates
            const peerCandRef = collection(peerConnRef, "candidates");

            // Queue for candidates that arrive before remote description
            const candidateQueue = [];

            const peerUnsubscribe = onSnapshot(peerConnRef, async snap => {
                const data = snap.data();
                if (data?.offer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(data.offer);
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    await setDoc(myConnRef, { answer }, { merge: true });
                    // Add queued candidates
                    candidateQueue.forEach(c => pc.addIceCandidate(c));
                    candidateQueue.length = 0;
                }
                if (data?.answer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(data.answer);
                    // Add queued candidates
                    candidateQueue.forEach(c => pc.addIceCandidate(c));
                    candidateQueue.length = 0;
                }
            });
            peers[peerId].unsubscribers.push(peerUnsubscribe);

            const candUnsubscribe = onSnapshot(peerCandRef, snap => {
                snap.docChanges().forEach(c => {
                    try {
                        const candidate = new RTCIceCandidate(c.doc.data());
                        if (pc.currentRemoteDescription) {
                            pc.addIceCandidate(candidate);
                        } else {
                            candidateQueue.push(candidate);
                        }
                    } catch (e) {
                        console.error("Error adding ICE candidate:", e);
                    }
                });
            });
            peers[peerId].unsubscribers.push(candUnsubscribe);

            if (caller) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await setDoc(myConnRef, { offer });
            }
        }

        async function leaveRoom() {
            if (!currentRoomId) return;

            // Unsubscribe from all Firebase listeners
            unsubscribers.forEach(unsub => unsub());
            unsubscribers = [];

            // Stop screen share if active
            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
            }

            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            // Close all peer connections
            Object.values(peers).forEach(pc => {
                if (pc.unsubscribers) {
                    pc.unsubscribers.forEach(unsub => unsub());
                }
                pc.close();
            });
            peers = {};

            // Remove from Firebase
            const participantsRef = collection(db, "rooms", currentRoomId, "participants");
            await setDoc(doc(participantsRef, userId), { left: Date.now() }, { merge: true });

            // Remove all audio elements
            document.querySelectorAll("audio").forEach(audio => audio.remove());
            document.getElementById("videos").innerHTML = "";

            // Reset UI
            document.getElementById("join").style.display = "inline";
            document.getElementById("leave").style.display = "none";
            document.getElementById("shareScreen").style.display = "none";
            document.getElementById("shareScreen").textContent = "Share Screen";
            document.getElementById("roomId").disabled = false;
            document.getElementById("status").textContent = "Left the call";
            
            currentRoomId = null;
        }

        async function toggleScreenShare() {
            if (screenStream) {
                // Stop screen sharing
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
                
                // Remove video track from all peers and renegotiate
                for (const [peerId, pc] of Object.entries(peers)) {
                    const senders = pc.getSenders();
                    const videoSender = senders.find(s => s.track?.kind === "video");
                    if (videoSender) {
                        pc.removeTrack(videoSender);
                        
                        // Renegotiate
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        const myConnRef = doc(
                            db, "rooms", currentRoomId, "participants",
                            userId, "connections", peerId
                        );
                        await setDoc(myConnRef, { offer }, { merge: true });
                    }
                }
                
                document.getElementById("shareScreen").textContent = "Share Screen";
                document.getElementById("status").textContent = "Stopped screen sharing";
            } else {
                // Start screen sharing
                try {
                    screenStream = await navigator.mediaDevices.getDisplayMedia({ 
                        video: true 
                    });
                    
                    const videoTrack = screenStream.getVideoTracks()[0];
                    
                    // Add video track to all peers and renegotiate
                    for (const [peerId, pc] of Object.entries(peers)) {
                        pc.addTrack(videoTrack, screenStream);
                        
                        // Renegotiate
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        const myConnRef = doc(
                            db, "rooms", currentRoomId, "participants",
                            userId, "connections", peerId
                        );
                        await setDoc(myConnRef, { offer }, { merge: true });
                    }
                    
                    // Handle when user stops sharing via browser button
                    videoTrack.onended = () => {
                        screenStream = null;
                        document.getElementById("shareScreen").textContent = "Share Screen";
                        document.getElementById("status").textContent = "Screen sharing stopped";
                    };
                    
                    document.getElementById("shareScreen").textContent = "Stop Sharing";
                    document.getElementById("status").textContent = "Sharing screen...";
                } catch (err) {
                    console.error("Error sharing screen:", err);
                    let errorMsg = "Could not share screen. ";
                    if (err.name === "NotAllowedError") {
                        errorMsg += "Permission denied.";
                    } else if (err.name === "NotSupportedError") {
                        errorMsg += "Screen sharing not supported. Use HTTPS or localhost.";
                    } else if (err.name === "NotFoundError") {
                        errorMsg += "No screen available to share.";
                    } else {
                        errorMsg += err.message || "Unknown error.";
                    }
                    alert(errorMsg);
                    document.getElementById("status").textContent = errorMsg;
                }
            }
        }

        document.getElementById("join").onclick = joinRoom;
        document.getElementById("leave").onclick = leaveRoom;
        document.getElementById("shareScreen").onclick = toggleScreenShare;
    </script>
</body>
</html>
