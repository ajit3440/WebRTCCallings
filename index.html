<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Group Voice Call</title>
    <link rel="icon" href="data:,">
</head>

<body>
    <h2>Group Voice Call (Firebase + WebRTC)</h2>

    <input id="roomId" placeholder="Room ID">
    <button id="join">Join</button>

    <script type="module">
        import { initializeApp } from
            "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";

        import {
            getFirestore,
            doc,
            setDoc,
            getDocs,
            onSnapshot,
            collection,
            addDoc
        } from
            "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBRbfuMB_J7ADzWYcnI2UmUmTuLYoY3G6Q",
            authDomain: "webrtc-a3cd5.firebaseapp.com",
            projectId: "webrtc-a3cd5",
            storageBucket: "webrtc-a3cd5.firebasestorage.app",
            messagingSenderId: "203007627814",
            appId: "1:203007627814:web:a947bb1227f5e390f78ce7"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        console.log("Firebase loaded successfully");

        const userId = crypto.randomUUID();
        let localStream;
        let peers = {};

        const servers = {
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        };

        async function joinRoom() {
            const roomId = document.getElementById("roomId").value;
            if (!roomId) return alert("Enter Room ID");

            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

            const participantsRef = collection(db, "rooms", roomId, "participants");
            await setDoc(doc(participantsRef, userId), { joined: Date.now() });

            const snapshot = await getDocs(participantsRef);
            snapshot.forEach(p => {
                if (p.id !== userId) connect(roomId, p.id, true);
            });

            onSnapshot(participantsRef, snap => {
                snap.docChanges().forEach(c => {
                    if (c.type === "added" && c.doc.id !== userId) {
                        connect(roomId, c.doc.id, false);
                    }
                });
            });
        }

        async function connect(roomId, peerId, caller) {
            const pc = new RTCPeerConnection(servers);
            peers[peerId] = pc;

            localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

            pc.ontrack = e => {
                const audio = document.createElement("audio");
                audio.srcObject = e.streams[0];
                audio.autoplay = true;
                document.body.appendChild(audio);
            };

            // My outgoing candidates
            const myCandRef = collection(
                db, "rooms", roomId, "participants",
                userId, "connections", peerId, "candidates"
            );

            pc.onicecandidate = e =>
                e.candidate && addDoc(myCandRef, e.candidate.toJSON());

            // My connection document (where I write my offer/answer)
            const myConnRef = doc(
                db, "rooms", roomId, "participants",
                userId, "connections", peerId
            );

            // Peer's connection document (where I read their offer/answer)
            const peerConnRef = doc(
                db, "rooms", roomId, "participants",
                peerId, "connections", userId
            );

            // Peer's candidates
            const peerCandRef = collection(peerConnRef, "candidates");

            // Queue for candidates that arrive before remote description
            const candidateQueue = [];

            onSnapshot(peerConnRef, async snap => {
                const data = snap.data();
                if (data?.offer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(data.offer);
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    await setDoc(myConnRef, { answer }, { merge: true });
                    // Add queued candidates
                    candidateQueue.forEach(c => pc.addIceCandidate(c));
                    candidateQueue.length = 0;
                }
                if (data?.answer && !pc.currentRemoteDescription) {
                    await pc.setRemoteDescription(data.answer);
                    // Add queued candidates
                    candidateQueue.forEach(c => pc.addIceCandidate(c));
                    candidateQueue.length = 0;
                }
            });

            onSnapshot(peerCandRef, snap => {
                snap.docChanges().forEach(c => {
                    const candidate = new RTCIceCandidate(c.doc.data());
                    if (pc.currentRemoteDescription) {
                        pc.addIceCandidate(candidate);
                    } else {
                        candidateQueue.push(candidate);
                    }
                });
            });

            if (caller) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await setDoc(myConnRef, { offer });
            }
        }

        document.getElementById("join").onclick = joinRoom;
    </script>
</body>
</html>
